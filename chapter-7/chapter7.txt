Chapter 7: Developing and
utilizing AI agents
Throughout the book, we’ve covered a wide range of topics from fundamental
concepts to real-world applications, including setting up a local environment with
LLMs, boosting their capabilities with RAG, fine-tuning, generating SQL queries,
and image processing. This chapter will focus on how LLMs can act as personal
assistants, enhancing our productivity in everyday life.
The ultimate frontier of Generative AI lies in AI agents. AI agents are advanced
systems that use generative models to perform complex tasks involving understand-
ing, generating, and interacting with natural language. These agents are built to
simulate human-like interactions, automate decision-making, and support a wide
range of applications, from content creation to personalized user experiences.
In 2024, major IT giants like Google, Microsoft, and Salesforce are increasingly
focusing on AI agents to automate complex workflows for their customers. Google
envisions AI agents as key players in managing both the complexity of workflows
and the coordination across multiple systems.
As business applications become more intertwined with various systems, AI
agents can harness the power of LLMs to perform tasks autonomously or semi-
autonomously. These agents are designed to streamline workflows by combining
the language model’s ability to understand and generate human-like text with
capabilities such as memory, planning, and interacting with external tools or
environments.
The future of AI agents
Looking ahead, AI agents will evolve through a series of progressive stages as they
become more integrated into enterprise operations. By automating both simple and
Chapter 7: Developing and utilizing AI agents 235
complex tasks, AI agents will free up human workers to focus on creative problem-
solving and strategic decision-making.
Figure 7.1
According to Google Cloud’s observations, this transformation will occur in three
key phases:
1. Task-Specific Agents. The first wave of AI agents will focus on specialized,
well-defined tasks. These agents will be designed to handle repetitive or routine
processes, significantly improving efficiency in specific areas. For example, an
AI agent might handle customer inquiries in a call center, automate data entry,
or generate reports based on structured data. These early AI agents will excel
at doing one thing extremely well, allowing enterprises to automate smaller,
isolated tasks.
2. Assistive AI Agents. The next step will involve the development of more
versatile AI assistants, capable of working alongside humans to enhance
productivity. These agents won’t just complete tasks independently but will
actively collaborate with human workers, offering suggestions, providing real-
time insights, and automating parts of more complex tasks. For example, an
Chapter 7: Developing and utilizing AI agents 236
AI assistant can help a marketing professional write campaign content or assist
a software developer by generating code snippets, making their work faster to
complete.
3. Multi-Agent Systems. In the most advanced phase, we’ll see the emergence
of multi-agent systems. These systems will consist of multiple AI agents
working together to tackle complex, end-to-end processes that span across
departments or workflows. In this stage, AI agents will coordinate among
themselves to execute large-scale operations, such as managing an entire
supply chain or handling a multi-step approval process. The agents will be
able to autonomously delegate tasks to one another and adapt to the specific
requirements of different stages in the workflow.
Info
Don’t be surprised if you encounter new BPMN activity types, such as AI
Agent, integrated into workflows in the near future.
At these moments, several companies and IT giants are already working seriously
on developing Assistive and Multi-agent AI systems. While these systems are still
in their early stages, they are capable of solving specific tasks. In our view, we are
at a turning point between the era of Task-Specific Agents and Assistive AI
Agents. In the near future, AI agents are likely to become an essential part of business
processes, with multi-agent systems playing a key role in optimizing workflows and
driving innovation across industries.
Difference between AI Agents and AI Tools
You’ve probably heard about AI tools that are now integrated into many online
services like Canva, Draw.io, and Adobe. The distinction between AI agents and AI
tools is subtle but significant, differing in functionality, interactivity, and autonomy.
AI tools are software applications that utilize artificial intelligence to perform specific
tasks. These tasks are typically narrow in scope and require explicit instructions from
Chapter 7: Developing and utilizing AI agents 237
the user. AI tools are designed to assist users in completing particular functions,
such as data analysis, natural language processing, image recognition, or content
generation.
AI agents, on the other hand, are more advanced and dynamic systems that possess
a degree of autonomy. They are designed to perform tasks, make decisions, and
adapt to new information or environments without constant human intervention. AI
agents can be thought of as intelligent entities that interact with their surroundings
and take action to achieve specific goals.
Key differences:
Feature AI Tools AI Agents
Scope of
Functionality
Narrow and
task-specific
Broad, can handle
multiple related tasks
Decision-Making Limited, follows
predefined rules
Dynamic, can make
decisions based on
changing data
User Interaction Requires explicit user
commands
Operates
autonomously, can
initiate actions
Adaptability Little to no
adaptation without
reprogramming
Learns and adapts
from experience and
environment
Examples Grammarly, Canava,
Adobe
Alexa, trading bots
While both AI agents and AI tools are integral to the AI ecosystem, they serve
different roles. AI tools enhance user productivity by performing specific tasks
efficiently, while AI agents offer a higher level of autonomy, enabling them to
perform complex, multi-step tasks with minimal human oversight. Consequently,
in the final chapters of this book, we will focus exclusively on AI agents.
Chapter 7: Developing and utilizing AI agents 238
Use cases of AI agents in Generative AI
Now that we have a clear understanding of what an AI agent is and its capabilities,
let’s explore its primary use cases. Since many of us work in the IT industry, it would
be useful to explore use cases from both the developer and product owner/manager
perspectives.
Use cases from a developer’s perspective
From a developer’s perspective, AI agents offer a range of powerful use cases that
streamline workflows, automate repetitive tasks, and even provide creative solutions
to complex problems. Here are some key use cases where AI agents can play a pivotal
role:
• Automated code generation: AI agents can assist developers by automatically
generating code based on a given problem or specification. These agents
analyze the requirements provided by the developer, understand the program-
ming context, and generate code snippets or even entire functions. Many
companies, such as JetBrains and Sbertech are now incorporating AI-powered
assistants directly into their Integrated Development Environments (IDEs).
This integration enables developers to automate repetitive tasks, simplify the
development process, and focus on higher-level coding activities.
– Use Case: Writing boilerplate code, setting up project structures, or
creating common algorithms.
– Benefit: Saves time on routine tasks, allowing developers to focus on more
complex problem-solving.
• Debugging and сode refactoring: AI agents can autonomously detect bugs in
the code, suggest fixes, or refactor code for better performance and readability.
These agents analyze the codebase, pinpoint inefficient or error-prone areas,
and provide solutions.
– Use Case: Identifying performance bottlenecks or memory leaks in a large
codebase.
Chapter 7: Developing and utilizing AI agents 239
– Benefit: Increases code quality and reduces the time spent manually
searching for bugs or inefficiencies.
• Automated testing: AI agents can automate unit, integration, and end-to-end
testing by generating test cases and analyzing application behavior. They can
simulate user interactions, stress-test applications, and identify vulnerabilities
or areas for improvement.
– Use Case: Automatically generating tests for new features or performing
regression testing after updates.
– Benefit: Speeds up the testing process and ensures higher code reliability
with fewer missed bugs.
• Documentation generation: One of the most time-consuming tasks that
programmers often dread is creating detailed documentation. However, AI
agents can now take care of this chore, freeing developers to focus on more
interesting work. By analyzing codebases, function definitions, and parameters,
AI agents can automatically generate high-quality documentation, saving
developers from the tedious task of writing it themselves.
– Use Case: Generating API documentation or in-line code comments for
large codebases.
– Benefit: Enhances code maintainability and makes it easier for other
developers to understand the project.
• AI-Driven design and architecture recommendations: AI agents can assist
in system design by analyzing current architectures and recommending im-
provements. For example, they can suggest more efficient data structures,
microservices design patterns, or cloud architecture optimizations. There are
a couple of AI tools, plugins and agents available to do the stuff easily.
– Use Case: Recommending better database schemas, suggesting the use of
microservices vs. monoliths, or proposing caching strategies.
– Benefit: Optimizes system performance and scalability by suggesting best
practices based on AI-driven analysis.
Chapter 7: Developing and utilizing AI agents 240
• Collaboration and knowledge sharing: AI agents can serve as a knowledge
base for development teams, providing real-time answers to technical ques-
tions, suggesting relevant documentation, or even recommending best practices
for specific scenarios.
– Use Case: Answering queries about coding standards or suggesting solu-
tions from past projects.
– Benefit: Enhances collaboration by making knowledge easily accessible
across the team.
Beyond these specific use cases, AI agents can also greatly benefit developers and
teams by boosting their productivity. For instance, in CI/CD pipelines, they save
time, improve efficiency, and provide valuable insights and automation capabilities
that minimize human error. As AI agents continue to evolve, their role will become
even more essential in the software development lifecycle, allowing developers
to concentrate on innovative tasks while the agents handle routine operational
complexities.
Use cases from a product manager’s perspective
From a product manager’s (owner’s) perspective, AI agents offer numerous use
cases that can enhance product development, improve customer experience, and
streamline operations. Here are several key use cases where AI agents play a crucial
role in product management:
• Automating product roadmap prioritization: AI agents can assist in automat-
ing the prioritization of product features or backlog items by analyzing factors
like customer demand, market trends, development resources, and potential
ROI. These agents help product managers make more informed, objective
decisions on what to prioritize next.
– Use Case: Using AI to rank new feature requests based on customer
demand and projected business impact.
– Benefit: Ensures that product teams focus on the most valuable features,
reducing the risk of misaligned priorities and wasted resources.
Chapter 7: Developing and utilizing AI agents 241
• Competitive analysis and market monitoring: AI agents can continuously
monitor the market, track competitors, and analyze industry trends in real-time.
They can alert product managers to shifts in the competitive landscape or new
market opportunities, allowing for more agile and strategic product planning.
– Use Case: An AI agent tracking competitor product launches, pricing
strategies, or user feedback in real-time.
– Benefit: Keeps product managers informed about the competitive land-
scape and allows them to adjust their product strategies proactively.
• Predictive analytics for demand forecasting: AI agents can analyze historical
data and market trends to predict future demand for products or services. This
can help product managers plan for inventory, manage supply chains, and
forecast revenue more accurately.
– Use Case: AI agents predicting seasonal demand for a product, helping
with inventory and production planning.
– Benefit: Reduces the risk of overproduction or stock shortages, improving
operational efficiency and profitability.
• Proactive risk management: AI agents can predict potential risks in the
product lifecycle, such as delays in development, supply chain disruptions, or
shifts in customer demand. These agents provide early warnings, allowing
product managers to mitigate risks before they impact the product’s success.
– Use Case: An AI agent detecting delays in development timelines and
suggesting alternative approaches or resource reallocations.
– Benefit: Reduces the likelihood of missed deadlines or cost overruns,
ensuring smoother product launches and operations.
• Automated customer support: AI agents can act as virtual assistants, handling
customer inquiries and support requests in real-time. They can engage in
natural language conversations, answering frequently asked questions, trou-
bleshooting common issues, and even escalating complex problems to human
agents when needed.
– Use Case: Automating 24/7 customer support through chatbots or voice-
based agents.
Chapter 7: Developing and utilizing AI agents 242
– Benefit: Reduces the need for human support staff, lowers operational
costs, and improves response times, all while ensuring customers receive
consistent service.
• Pricing optimization: AI agents can dynamically adjust pricing based on
demand, market conditions, customer behavior, and competitive pricing. By
continuously analyzing these factors, AI agents ensure that product prices are
optimized for maximum profitability.
– Use Case: An AI agent recommending price changes during peak demand
periods or offering discounts during slow sales periods.
– Benefit: Maximizes revenue and ensures competitive pricing strategies in
real-time.
From a product management perspective, AI agents bring a major breakthrough in
automating and optimizing the product development process. This approach can also
be applied to analyzing user behavior or creating personalized experiences for users.
By harnessing the power of AI agents, product managers can make more informed
decisions, deliver better user experiences, and stay ahead in today’s rapidly changing
market.
Classification of AI Agents in Generative AI
AI agents in the context of generative AI can be classified based on their complexity,
functionality, and interaction capabilities. Within this domain, we can classify AI
agents into three categories:
1. Based on Functionality and Application:
• Content generation agents: These agents use generative models to create
content, such as articles, stories, code, or images. They are often used in
creative industries or for automating content creation.
– Example: An AI framework that generates marketing materials, blog
posts, or social media content based on input prompts.
Chapter 7: Developing and utilizing AI agents 243
• Conversational agents: These agents focus on engaging in natural lan-
guage dialogues with users. They can handle tasks like answering queries,
conducting customer support, or simulating human conversation.
– Example: Chatbots based Llama or virtual assistants like Google
Assistant and Alexa.
• Task-Oriented agents: These agents are designed to perform specific
tasks, such as booking appointments, managing schedules, or executing
commands within predefined domains.
– Example: An AI assistant that can manage emails, set reminders, and
perform basic administrative tasks based on user input.
• Information retrieval agents: These agents specialize in accessing and
retrieving information from various sources, including databases, APIs,
and knowledge bases. They can combine retrieved information with LLM
capabilities to generate comprehensive responses.
– Example: An agent that answers technical queries by pulling data from
scientific databases and explaining it in natural language.
• Multi-Modal agents: These agents can handle inputs and outputs in
multiple formats, such as text, images, and voice. They integrate various
AI capabilities, including language models, computer vision, and speech
recognition.
– Example: An AI agent that can analyze images, respond to voice
commands, and generate written reports.
2. Based on Interaction and Integration Capabilities:
• Memory-Augmented agents: These agents maintain a memory of past
interactions, user preferences, and contextual information, enabling them
to provide more coherent and contextually relevant responses over time.
– Example: A virtual tutor that remembers a student’s progress and
adjusts its teaching approach accordingly.
Chapter 7: Developing and utilizing AI agents 244
• Autonomous agents: Autonomous agents operate independently, making
decisions and taking actions without continuous user input. They are
capable of setting their own goals and executing plans to achieve those
goals.
– Example: An autonomous trading bot that buys and sells stocks based
on market analysis without direct human intervention.
3. Based on Learning and Adaptation:
• Pre-Trained agents: These agents use pre-trained LLMs to perform tasks
without additional fine-tuning or learning from new data. They rely on
the capabilities of the underlying model.
– Example: A chatbot that uses Llama to answer general knowledge
questions based on its pre-trained knowledge.
• Fine-Tuned agents: These agents are customized for specific tasks or
domains through fine-tuning on specialized datasets. They offer improved
performance in their targeted areas.
– Example: An AI assistant fine-tuned on medical data to provide
healthcare-related advice.
• Adaptive learning agents: These agents can learn and adapt from new
data during their deployment. They improve their performance over time
by incorporating feedback and new information.
– Example: A customer service bot that improves its responses based on
user interactions and feedback.
This classification is not exhaustive, but it provides a solid foundation for under-
standing the various types of AI agents in generative AI. As this field continues to
evolve, new sub-categories and applications are likely to emerge!
Chapter 7: Developing and utilizing AI agents 245
AI agents architecture
AI agent architectures can vary depending on their classification or purpose. For
instance, a fine-tuned agent might include components like learning layers that help
it adapt over time. In contrast, a content creation agent might require additional
components for tasks like tokenization or text embedding. In this section, we will
cover a basic architecture of an AI agent that is commonly used for performing
everyday tasks.
AI agents are complex systems built from different modules to perform tasks like
understanding language, making decisions, and interacting with the environment.
To explain the architecture of an AI, we can break down the components by its
functionalities. Here’s a detailed breakdown with a conceptual diagram.
Figure 7.2
The architecture of an AI agent consists of the following components:
1. Input. This component takes input from the environment or user (e.g.,
text, images, or sensor data). For a conversational agent, it could include
Natural Language Processing (NLP) components that convert speech to text
and preprocess it.
• Key elements:
1. Sensors (for robotic AI agents)
Chapter 7: Developing and utilizing AI agents 246
2. Text/Speech/Video inputs (for virtual agents)
3. Preprocessing (tokenization, normalization, etc.)
2. Brain or Processing. This is the core logic where the agent processes input
to understand and generate output. It involves various models and algorithms
such as:
• NLP Model: For understanding language in chatbots or virtual assistants.
• Perception Models: In image or video agents (e.g., object recognition,
image classification).
• Decision-Making Models: For reasoning, planning, or predicting actions.
• Key elements:
1. Large Language Models (LLMs)
2. Perception Models (e.g., CNNs, RNNs)
3. Rule-based engines
3. Storage. This components stores the agent’s knowledge, previous interactions,
and any additional external information. Agents may access:
• Short-term Memory: To remember recent interactions.
• Long-term Knowledge Base: Which may contain facts, rules, or learned
models.
• Key elements:
1. In-memory database
2. Databases (structured and unstructured)
3. Embedding Stores (Vector DB)
4. Learning. AI agents often adapt over time. This layer allows agents to update
their models or learn from new data.
• Key elements:
– Supervised/Unsupervised Learning
– Reinforcement Learning (updating policies based on feedback)
– Fine-tuning Models
– Continuous Learning
Chapter 7: Developing and utilizing AI agents 247
5. Action. Sometime this component also called tools. This component defines
how the agent interacts with its environment or users, such as generating
responses in text, executing commands, or invoking 3rd party API.
• Key elements:
– Text/Audio Generation (e.g., GPT or TTS models)
– Actuators (for robotic agents)
– APIs/Commands (to external systems)
6. Feedback. AI agents use this layer to evaluate their own performance and
make adjustments, often feeding back into the learning layer. This component
ensures the agent can evaluate its performance and learn from its mistakes.
• Key elements:
– Reward Functions (in RL)
– Error Monitoring (to check for failures)
– User Feedback (for improvement)
7. Planner. This component breaks down complex tasks into manageable steps. In
some cases it also uses workflow engine or pipeline to execute tasks sequently.
• Key elements:
– Workflow engine
– Tasks pipeline
Depending on the agent’s framework or implementation, its architecture may
vary. However, most AI agent frameworks include these core components, though
they may be referred to by different names. Together, these components form a
comprehensive agent capable of working with LLMs to complete complex user tasks.
Frameworks for developing AI Agents
Developing AI agents requires a robust and efficient framework that supports
various architectures, algorithms, and programming languages. At the time of
Chapter 7: Developing and utilizing AI agents 248
writing this book, there are over 150 frameworks and tools available for creating
AI agents. You can find a comprehensive list of these agents here. However, many
of these tools are specialized for specific tasks and do not require prior programming
knowledge, while others are designed for solving a broader range of tasks and require
advanced programming skills. Below are some of the most widely used open-source
frameworks for building AI agents using large language models (LLMs):
1. Langchain and LangGraph.
LangChain is a complete framework designed to simplify the development of
applications that integrate LLMs with external data sources, workflows, or APIs.
Its main goal is to create a chain-based system capable of performing tasks like
answering questions, executing commands, and interacting with external systems
using models like GPT or local models such as LLaMA. Moreover, it provides a
new sub project named LangGraph orchestration framework for developing complex
agentic system.
Info
Common Confusions between LangChain and LangGraph: LangChain
also introduces agents, which are useful for building agent-based systems.
In Chapter 4, we discuss the LangChain SQL agent for handling errors
while executing SQL queries. In contrast, LangGraph is a library built on
top of LangChain, specifically designed for creating stateful, multi-actor
applications and complex agent-based systems using LLMs.
• Key features of LangGraph:
– Graph structure: LangGraph leverages the graph concept to create a
powerful framework for building complex systems. Within LangGraph,
each node in the graph represents an individual LLM agent, while the edges
connecting these nodes facilitate communication between agents. This
architecture enables straightforward and manageable workflows, where
Chapter 7: Developing and utilizing AI agents 249
each LLM agent performs specific tasks and shares information with other
agents as required. This structure is also helpful for visualizing workflows
and dependencies.
– State managements: One of the key features of this framework is its
automatic state management. Each node in the graph receives the current
state, can modify it as needed, and then passes it on to the next node.
This approach enables the system to track and persist information across
multiple interactions. Furthermore, this feature also allows states to be
stored in external databases, such as SQLite or PostgreSQL, for added
flexibility and scalability.
– Error handling: LangGraph offers a robust mechanism for error handling,
allowing nodes to raise exceptions when errors occur during program
execution. This feature provides a flexible way to implement retry logic
within nodes, enabling them to handle exceptions and recover from errors.
By providing this functionality, LangGraph enables developers to write
more resilient code that can recover from unexpected issues.
• Pitfalls of LangGraph. Despite its robust feature set, LangGraph has it’s
limitations and challenges that developers should be aware of.
– Learning Curve:
* The modular nature of LnagGraph, while powerful, can also be com-
plex to understand and configure for new users. Building effective
Agent often requires a deep understanding of how different compo-
nents interact.
* Developers must spend time mastering prompt engineering, Graph
design, and agent behavior, which can be time-consuming.
– Resource-Intensive-:
* Running complex LangGraph can be computationally expensive, espe-
cially if the graph involve multiple nodes or require large amounts of
data processing.
* Developers need to balance performance with cost, especially when
using cloud-hosted LLMs or high-volume data sources.
LangChain, combined with LangGraph, forms a highly powerful framework for
building AI agents that can harness the capabilities of LLMs to interact with external
Chapter 7: Developing and utilizing AI agents 250
data and perform complex tasks. While this combination offers numerous benefits, it
also has some limitations that developers should be aware of, such as a steep learning
curve, potential scalability challenges, and increased debugging complexity. As a
result, those considering LangGraph for their projects should carefully balance its
flexibility against the potential overhead of learning and deploying it in production
environments.
2. CrewAI
CrewAI is another widely-used, high-level framework designed for role-based multi-
agent interactions. It focuses on creating and managing collaborative AI agents that
work together on complex tasks. The framework coordinates multiple AI models
or agents, making it ideal for tasks that require diverse expertise, such as content
creation, data analysis, and problem-solving across different fields.
Info
The term multi-agent refers to the independent collaboration of multiple
agents or actors, supported by the framework to complete complex tasks.
• Key features of CrewAI:
– Collaboration among AI Agents: CrewAI facilitates the formation of
crews or teams of AI agents that can communicate and share resources
to solve multi-faceted problems. Each agent can have specialized roles,
mimicking how human teams operate.
– Modular integration: The framework supports the integration of different
AI models, allowing for flexibility in combining models that specialize
in different tasks, such as language processing, image recognition, or
decision-making.
– Task orchestration: It offers sophisticated orchestration mechanisms that
allocate tasks to the most suitable agents within the crew based on their
capabilities. This can involve dynamic adjustment as the complexity of the
task evolves.
Chapter 7: Developing and utilizing AI agents 251
– Scalability: CrewAI is built with scalability in mind, making it capable
of managing large-scale, real-time operations, such as customer support
systems or real-time monitoring solutions.
– Human-in-the-Loop: CrewAI allows for human oversight, where human
operators can step in to guide or modify the behavior of the AI agents,
especially in scenarios requiring ethical judgment or high-stakes decisions.
– Easy learning curve: The learning curve of CrewAI is considered rel-
atively easy for several reasons, making it a popular framework among
non-technical users.
* High-Level Abstractions: CrewAI provides intuitive, high-level ab-
stractions for managing AI agents and tasks, so developers can focus on
defining roles and interactions without getting bogged down in low-
level details.
* User-Friendly APIs: CrewAI offers user-friendly APIs and well-
documented functions, making it easier for beginners to grasp and use
without requiring extensive knowledge of AI architectures.
• Pitfalls of CrewAI. Although CrewAI is popular among non technical persons
for creating social network content, it has some disadvantages include:
– Poorly Designed Prompts: Some built-in prompts are hardcoded with
significant grammar and spelling errors, which hinder their usability.
– Invasive Telemetry: The presence of hardcoded telemetry that cannot be
disabled raises privacy and user control concerns.
While we’ve only had space to cover two popular frameworks in this book, there are
several others worth noting:AutoGen and Vertex AI Agent Builder. Both AutoGen,
developed by Microsoft, and Vertex AI Agent Builder, from Google, share a similar
architecture and provide a robust platform for creating enterprise-grade generative
AI applications and agents. What’s more, these tools allow developers to build
complex models without requiring expertise in deep machine learning.
In the next section, we’ll take a hands-on approach to exploring AI Agents in action.
We’ll create an agent from scratch, integrating it with a LLM, and demonstrate how
it can be used to perform specific tasks.
Chapter 7: Developing and utilizing AI agents 252
Developing a practical AI Agents: a
step-by-step Guide
So far, we have gained substantial knowledge about AI agents, covering their use
cases, architecture, and various frameworks. Traditionally, at this point in the
discussion, it’s time to provide a real-life example to illustrate their functionality
and capabilities. As usual, it was quite challenging to decide which example would
be ideal. We considered developing an agent for generating documentation from
codebases or summarizing daily emails.
However, given the rise of social media in today’s digital landscape, it makes more
sense to demonstrate a practical AI agent that generates content for platforms like
blogs. Smart personal assistants are becoming essential for boosting productivity and
simplifying daily tasks. CrewAI, is a powerful framework that allows developers to
create intelligent, collaborative AI agents without requiring extensive programming
knowledge. By leveraging CrewAI, we can orchestrate multiple specialized agents to
draft a blog post (though we will still need to rewrite and edit much of the content).
In this section, we will guide you through the process of creating a smart personal
assistant (agent) using CrewAI. This example will showcase its versatility and ease
of use, highlighting how different agents can handle specific functions—such as
task management, information retrieval, and communication—working together to
provide an efficient user experience.
Example Use Case:
In our weekly routine, we plan to publish a blog post on how to install and deploy
Apache Ignite, an in-memory database, on Docker and Kubernetes. Our goal is to
provide a detailed, step-by-step tutorial to guide our audience through the process.
To save time, we decided to use CrewAI to generate an outline and a draft of the blog
post, which we will later edit and refine. Below is how the process would look using
CrewAI.
Chapter 7: Developing and utilizing AI agents 253
Figure 7.3
Before we get started, let’s cover some basic information about CrewAI.
Core components:
1. Agents: Agents are autonomous entities within CrewAI that perform specific
tasks. Each agent typically has its own set of skills and knowledge base.
• key attributes of the Agent:
– Role: Agents can handle diverse tasks such as information retrieval,
reasoning, decision-making, or even interaction with external envi-
ronments. They can either operate independently or collaboratively
within a crew.
– Goal: The specific objective the agent aims to achieve.
– Backstory: Context and background information to guide the agent’s
behavior and interactions.
– Tools: Custom tools and utilities that the agent uses to perform its
tasks.
Chapter 7: Developing and utilizing AI agents 254
2. Execution flow: The execution flow governs the sequence and logic by which
agents perform tasks and interact with other agents or tools. It orchestrates the
order in which agents operate, ensuring tasks are executed efficiently and in
the correct sequence. The flow can be linear, parallel, or conditional based on
the task requirements.
• key attributes of the Execution flow:
– Initialization: Setting up agents and tasks based on configuration.
– Task Assignment: Assigning tasks to the appropriate agents.
– Execution: Execute tasks according to the defined process (sequential
or parallel).
3. Tasks: Tasks are the units of work assigned to agents within CrewAI.
• key attributes of the Tasks:
– Description: A detailed explanation of what the task entails.
– Context: Dependencies and prerequisites required for the task.
– Agent Assignment: The specific agent responsible for executing the
task.
– Execution Mode: Whether the task is executed synchronously or
asynchronously.
4. Crew: A crew is a group of agents working together towards a common goal,
much like a human team.
• key attributes of the Crew:
– Agents: A list of agents that are part of the crew.
– Tasks: A list of tasks that need to be completed.
– Process Management: Defines how tasks are processed (e.g., sequen-
tially, in parallel).
5. Tools: Tools are external systems, APIs, or environments that agents use to
complete their tasks such as search engines or 3rd party REST API.
6. LLMs: Large Language Models, such as LLaMa, GPT, Mistral models, provide
agents with advanced natural language processing capabilities. LLM works as
a brain of the CrewAI.
Chapter 7: Developing and utilizing AI agents 255
To achieve our goal, we plan to use the following agents and tasks:
• Agents:
– Planner: The Content Planner. His job is to gather information on the
topics and prepare an outline for the blog post. The planner use the search
engine DuckDuckGo.
– Writer: The Technical Content Writer. His responsibility is to write a
detailed step-by-step tutorial based on the outline provided by the content
planner.
– Editor: The Post Editor. His task is to review the blog post, checking it for
grammar and clarity. Additionally, they will rewrite the content in a more
natural and readable style while preserving the original meaning.
• Tasks:
– Plan: Develop a detailed content outline that includes an introduction, key
values, main points, and step-by-step examples.
– Write: Create a detailed blog post using the content plan from the previous
step.
– Edit: Proofread the blog post for grammar errors and rewrite it for better
readability while maintaining its intended meaning.
• Execution Flow: The crew sets up the agents with their specific tasks. The
process is executed in a sequence, and the final results are compiled and
presented.
Now that our groundwork is complete and we have a clear understanding of how
to build an AI agent to achieve our goals, let’s get started with developing our first
multi-agent application.
Step 1: Ensure that you have the Ollama runner up and running with any LLM, such
as LLaMa or Mistral.
Step 2: Activate your conda environment with Jupyter. If you are struggling with
these two steps, please refer to Chapter 1 for detailed information.
Step 3: Create a new notebook in Jupyter and add the following fragment of Python
code.
Chapter 7: Developing and utilizing AI agents 256
!pip install crewai
!pip install duckduckgo-search
!pip install langchain_community
This code installs three Python packages using pip: crewai, duckduckgo-search,
and langchain_community. These libraries are necessary for building AI agents and
enabling search capabilities in the project.
Info
The complete notebook is available in the GitHub project directory. Please
refrain from copying and pasting the code from the book. Instead, you can
review and execute each cell one at a time.
Step 4: Import the necessary classes from the libraries
from langchain_community.llms import Ollama
from langchain_community.tools import DuckDuckGoSearchRun
from crewai import Agent, Task, Crew, Process
from langchain_openai import ChatOpenAI
from langchain_groq import ChatGroq
import os
Step 5: Initialize an instance of the language model (LLM)
Chapter 7: Developing and utilizing AI agents 257
llm = ChatOpenAI(
model = "llama3.1"
,
base_url = "http://192.168.1.124:11434/v1"
temperature=0.7,
max_tokens=1024,
timeout=None,
max_retries=2
,
)
This code snippet defines an LLM instance using the ChatOpenAI class imported from
the LangChain framework. Here’s a breakdown of some key parameters:
• model=llama3.1. This specifies the model version to be used. Change the name
of the model you uses in your Ollama runner.
• base_url="http://192.168.1.124:11434/v1". The URL of your local Ollama
runner.
• max_retries=2. Indicates how many times the request will be retried if it fails.
If you are using a low configuration pc or notebook, add more than 5.
Note that, depending on your topic and LLM instance configuration, the process may
consume a significant amount of computing resources. If you’re facing high resource
utilization issues, I highly recommend using a third-party LLM inference service like
Groq. To use Groq, add or uncomment the following pseudocode:
#api_key= os.environ.get("$GROQ_API_KEY")
#model_name="llama-3.1-70b-versatile"
#llm = ChatGroq(
# model=model_name,
# temperature=0.7,
# max_tokens=1024,
# timeout=None,
# max_retries=2
#)
Chapter 7: Developing and utilizing AI agents 258
Info
To understand what Groq is, please refer to Chapter 1, Section Hardware
Acceleration.
Step 6: Add the search engine tool using the following code and our desired input
prompt
search_tool = DuckDuckGoSearchRun()
inputs = {
"topic":"Step by step example of installing Apache Ignite on Docker\
"
.
,
"target_audience": "Programmer, Product owner, Analyst"
}
The first line of code initializes the search engine for use, while the next line defines
the blog post topic and the target audience for the AI agent.
Step 7: Add our first agent: the planner
#Content planner Agent
planner = Agent(
role="Content Planner"
,
goal="You are tasked with planning an engaging and informative blog\
post on {topic}"
,
backstory="You're working on planning a blog article "
"about the topic: {topic}.
"
"Your goal is to gather accurate, up-to-date information \
and structure the content "
"in a way that captures the reader’s interest while deliv\
ering valuable insights. "
"The audience for this blog post is {target_audience},
"
"and they are looking for clear, practical information th\
at they can apply immediately. "
"You must consider their needs, interests, and potential \
Chapter 7: Developing and utilizing AI agents 259
challenges they might face related to the topic. "
"Your job is to create an outline that will guide the wri\
ter in crafting a piece that "
"is both educational and easy to digest. "
"Your work is the base for "
"the Content Writer to write an article on this topic."
,
llm=llm,
allow_delegation=False,
verbose=True
)
This code snippet defines a Content Planner Agent using the Agent class. The agent’s
role is to plan the content for a blog article by gathering information and creating an
outline. This agent is not permitted to delegate tasks to other agents.
Step 8: Add the agent: the writer
#Content writer Agent
writer = Agent(
role='Technical content writer'
,
goal="You are the technical content writer assigned to create a detai\
led and factually accurate blog post on: {topic}"
,
backstory="You're working on a writing "
"a new step by step tutorial about the topic: {topic}.
"
"Your job is to ensure that the content is factually accu\
rate, well-organized, "
"and clearly explains the topic at hand. You will need to\
break down complex "
"technical concepts into simple, digestible parts, while \
still "
"maintaining depth and technical rigor. You must also inc\
orporate "
"relevant data, examples, and use cases to make the artic\
le practical and valuable to the reader. "
"You base your writing on the work of "
"the Content Planner, who provides an outline "
Chapter 7: Developing and utilizing AI agents 260
"and relevant context about the topic. "
"You follow the main objectives and "
"direction of the outline, "
"as provide by the Content Planner. "
"Your audience consists of {target_audience},
"
"who are likely seeking clear and actionable insights. "
"Whether it's professionals looking to apply the knowledg\
e "
"in their work, or beginners trying to grasp the basics, "
"your writing should meet their needs. Make sure to maint\
ain an "
"approachable tone, balancing technical depth with readab\
ility."
,
verbose=True,
allow_delegation=False,
llm=llm,
)
This code snippet defines a Content Writer Agent using the Agent class, which is
responsible for writing a detailed and factually accurate article. This agent is also
not allowed to delegate tasks.
Step 9: Add our final agent from the list: the editor
editor = Agent(
role="Editor"
,
goal="You responsible for reviewing and refining a blog post to ens\
ure it aligns with the clear, "
"concise, and engaging writing style of platforms like. 'https://dz\
one.com'
"
.
,
backstory="You are the technical content editor who receives a blog\
post "
"from the Content Writer. "
"Your goal is to make sure the post is grammatically corr\
ect, "
"free of errors, and easy to read. You will need to caref\
Chapter 7: Developing and utilizing AI agents 261
ully "
"check sentence structure, punctuation, and overall coher\
ence "
"while ensuring the tone remains conversational, yet info\
rmative—similar "
"to the approachable style used on Medium.com. The conten\
t should feel "
"natural, guiding readers effortlessly from one section t\
o the next, "
"while maintaining technical accuracy."
,
llm=llm,
allow_delegation=False,
verbose=True
)
This code defines an Editor Agent whose primary responsibility is to edit blog posts
to ensure they align with the writing style of a specific organization. The editor
reviews the content for adherence to journalistic standards, maintains a balanced
viewpoint, and avoids controversial topics.
Info
Note that prompt engineering plays a crucial role in providing a strong
backstory for the agents. The better the context and instructions you
provide, the better the output will be.
Now, we are ready to define tasks for each agent.
Step 10: Add the task plan
Chapter 7: Developing and utilizing AI agents 262
# Create tasks for the planner agent
plan = Task(
description=(
"1. Step by step example , "
"and noteworthy latest news on {topic}.\n"
"2. Identify the target audience, considering "
"their interests and pain points.\n"
"3. Develop a detailed content outline including "
"an introduction, values, key points, and step by step exam\
ple.\n"
"4. Include SEO keywords and relevant data or sources."
),
expected_output="A comprehensive content plan document "
"with an outline, audience analysis, "
"SEO keywords, and resources."
,
agent=planner,
tools=[search_tool],
)
This above code defines a Task for the planner agent, which outlines specific steps
the agent needs to take in planning content. The task will utilize the search tool
DuckDuckGo to gather information, news, and data necessary for the content planning
process.
Step 11: Our next task write
write = Task(
description=(
"1. Use the content plan to craft a compelling "
"blog post on {topic}.\n"
"2. Incorporate SEO keywords naturally.\n"
"3. Sections/Subtitles are properly named "
"in an engaging manner.\n"
"4. Ensure the post is structured with an "
"engaging introduction, insightful body, "
"and a summarizing conclusion.\n"
Chapter 7: Developing and utilizing AI agents 263
"5. Proofread for grammatical errors and "
"alignment with the brand's voice.\n"
),
expected_output="A well-written blog post "
"in markdown format, ready for publication, "
"each section should have 3 or 5 paragraphs."
agent=writer,
,
)
Here, we define a task for the writer agent with specific instructions on how to craft
a blog post. The task involves using a content plan, incorporating SEO keywords,
naming sections engagingly, structuring the post effectively, and proofreading for
errors and brand alignment.
Step 12: Our final task is edit. Add the following code into a new cell
edit = Task(
description=("Proofread the given blog post for "
"grammatical errors and "
"alignment with human language for better readability \
while maintaining its original meaning."),
expected_output="A well-written blog post in markdown format, "
"ready for publication, "
"each section should have 3 or 5 paragraphs."
,
agent=editor
)
This code defines a task for the editor agent focused on proofreading a blog post.
The task involves checking for grammatical errors, ensuring the content aligns with
natural language for improved readability, and maintaining the original meaning of
the text. The expected output is a polished blog post in markdown format, ready for
publication, with each section containing a specified number of paragraphs.
Step 13: Let’s initialize the crew, our final step to complete the development of the
agents
Chapter 7: Developing and utilizing AI agents 264
# Instantiate the crew with a sequential process
crew = Crew(
agents=[planner, writer, editor],
tasks=[plan, edit, write],
verbose=2, # You can set it to 1 or 2 to different logging levels
)
# run the crew
result = crew.kickoff(inputs=inputs)
print("**Final result**")
print(result)
Here, we initialize a Crew instance consisting of a planner, writer, and editor, with
each assigned specific task to accomplish sequentially. The kickoff method is called
to run the crew with the provided inputs, and the final result is printed to the console.
Run all cells by clicking the button on the menu bar. If everything goes smoothly,
you will start seeing output in the console as shown below:
[2024-09-27 13:55:54][DEBUG]: == Working Agent: Content Planner
[2024-09-27 13:55:54][INFO]: == Starting Task: 1. Step by step example\
, and noteworthy latest news on Step by step example of installing Apa
che Ignite on Docker..
2. Identify the Programmer, Product owner, Analyst, considering their i\
nterests and pain points.
3. Develop a detailed content outline including an introduction, values\
, key points, and step by step example.
4. Include SEO keywords and relevant data or sources.
> Entering new CrewAgentExecutor chain...
Thought: To create a comprehensive content plan for the blog post "Step\
by step example of installing Apache Ignite on Docker", I need to star
t by gathering information on the latest news and updates on Apache Ign
ite and Docker.
Chapter 7: Developing and utilizing AI agents 265
Action: duckduckgo_search
Action Input: {"query": "Apache Ignite Docker latest news"}
...
Thought: Based on the gathered information, I can create a comprehensiv\
e content plan for the blog post "Step by step example of installing Ap
ache Ignite on Docker".
Final Answer:
**Content Plan for "Step by step example of installing Apache Ignite on\
Docker"**
**Target Audience:**
* Programmer
* Product owner
* Analyst
**Interests and Pain Points:**
* Programmers: looking for a step-by-step guide to install Apache Ignit\
e on Docker, interested in learning about the latest versions and updat
es.
* Product owners: interested in understanding the benefits and challeng\
es of using Apache Ignite on Docker, looking for a practical guide to i
mplementation.
* Analysts: looking for information on the scalability and performance \
of Apache Ignite on Docker, interested in understanding the technical r
equirements.
... omitted for space saving purpose.
The log provides a detailed sequence of actions taken by the Content Planner,
Writer, and Editor agents in a multi-agent system. The Content Planner first gathers
Chapter 7: Developing and utilizing AI agents 266
information to create a content outline and identify the target audience. Then, the
Writer agent generates the post based on the planner’s content, while the Editor
reviews and refines the blog post for grammatical accuracy and readability. This
sequential workflow reflects how these agents collaborate to produce a high-quality
piece of content.
Our generated blog post is lengthy because we requested 3 to 5 paragraphs for each
section.
# Step by Step Example of Installing Apache Ignite on Docker
===========================================================
## Introduction
---------------
Apache Ignite is a powerful, open-source distributed database for high-\
performance computing that can be used as a database, caching system, o
r for in-memory data processing. It is designed to work seamlessly with
various environments, including Docker. In this blog post, we will pro
vide a step-by-step guide on installing Apache Ignite on Docker, config
uring it with Spring Boot, and troubleshooting common issues.
Apache Ignite offers several features that make it an attractive choice\
for developers, including:
* In-memory computing for high-performance data processing
* Distributed database capabilities for scalability and reliability
* Support for ACID transactions and SQL queries
* Integration with popular frameworks such as Spring Boot
### Importance of Using Apache Ignite on Docker
Using Apache Ignite on Docker provides several benefits, including:
* Easy deployment and management of Apache Ignite instances
* Scalability and flexibility in deploying Apache Ignite on various e\
nvironments
Chapter 7: Developing and utilizing AI agents 267
* Improved performance and reliability in distributed computing
## Installing Apache Ignite on Docker
... ommited for space saving purpose.
The generated text provides a structured introduction and overview of installing
Apache Ignite on Docker. We can evaluate the generated text on several criteria,
including clarity, organization, content, and overall effectiveness.
Evaluation Criteria:
• Clarity:
– The text is clear and uses straightforward language, making it accessible
for readers who may be new to Apache Ignite or Docker.
– Technical terms are introduced in context, which aids understanding.
• Organization:
– The document is well-structured with clear headings (e.g., “Introduction,”
“Importance of Using Apache Ignite on Docker”).
– Each section logically flows into the next, guiding the reader through the
information.
• Content:
– Introduction: The introduction effectively summarizes what Apache Ignite
is and outlines its uses, making it clear why a reader would want to learn
about it. The list of features highlights the strengths of Apache Ignite,
appealing to potential users.
– Importance Section: This section outlines the benefits of using Apache
Ignite with Docker, emphasizing ease of deployment, scalability, and
performance. This section could be improved by adding examples or
specific scenarios where these benefits have been realized.
– Next Steps: The text transitions to the installation instructions but does
not provide them yet, suggesting that the tutorial continues beyond this
excerpt. This is a good approach for a step-by-step guide.
Chapter 7: Developing and utilizing AI agents 268
• Engagement:
– The content engages the reader by outlining the practical applications of
Apache Ignite and Docker.
– Bullet points effectively summarize key features and benefits, enhancing
readability and retention.
• Technical Accuracy:
– The descriptions of Apache Ignite’s capabilities appear accurate and rele-
vant to its use with Docker. However, this section should be reviewed and
rewrite for accuracy.
• Readability: The use of bullet points, short paragraphs, and headings enhances
readability. The language is appropriately technical without being overly
complex, which is crucial for a tutorial aimed at a wide audience.
The generated text provides a solid introduction to a tutorial on installing Apache
Ignite on Docker. It is clear, well-organized, and engaging. However, some sections
need to be reviewed and rewritten with additional technical details to make the
tutorial more informative and user-friendly, ensuring it is ready for publication.
At this point, we can wrap things up. With a few modifications to the provided
Python notebook, you can create your tour plan or generate stunning marketing
content for LinkedIn or Facebook. Simply add or edit the appropriate agent with
their roles, goals, and backstory, and specify the tasks for the agent to complete their
work. Most of the CrewAI framework is declarative, requiring less code and more
straightforward instructions, which is why it is so popular among non-technical
users.
Conclusion
In summary, AI agents within the realm of generative AI and LLMs represent a new
frontier in autonomous systems. They combine advanced language understanding
and generation with abilities like memory retention, tool usage, and real-time data
integration. By leveraging AI agents, many routine tasks can be delegated, freeing up
Chapter 7: Developing and utilizing AI agents 269
time for more important work. These agents can serve as personal digital assistants,
useful not only for individual tasks but also in business applications to solve complex
enterprise challenges.
Throughout the chapter, we explored the architecture of AI agents and their core
components. We also covered their classification and the most popular frameworks
for real-world use. Toward the end, we introduced the multi-agent framework
CrewAI, which allows non-technical users to manage AI agents and tasks through
intuitive, high-level abstractions.
We demonstrated the design and implementation of agents, tasks, and the Crew
system using a content generation example. The success of this example highlights
the potential of multi-agent systems to automate complex tasks and enhance pro-
ductivity across various domains.